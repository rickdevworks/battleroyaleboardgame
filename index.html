<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Battle Royale Board Game</title>
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Portrait warning overlay */
        #portrait-warning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            padding: 20px;
            text-align: center;
        }
        
        .warning-content {
            background: rgba(42, 42, 66, 0.95);
            padding: 40px;
            border-radius: 15px;
            border: 3px solid #4cc9f0;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0,0,0,0.7);
        }
        
        .warning-content h2 {
            color: #4cc9f0;
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        .warning-content p {
            color: #fff;
            margin-bottom: 30px;
            font-size: 18px;
            line-height: 1.5;
        }
        
        .rotate-icon {
            font-size: 80px;
            margin: 20px 0;
            color: #4cc9f0;
            animation: rotate 2s infinite ease-in-out;
        }
        
        @keyframes rotate {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(90deg); }
            50% { transform: rotate(0deg); }
            75% { transform: rotate(-90deg); }
            100% { transform: rotate(0deg); }
        }
        
        body {
            margin: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            min-height: 100vh;
            overflow: hidden;
            touch-action: manipulation;
        }
        
        /* Burger menu */
        #burger-menu {
            display: flex;
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 1000;
            background: rgba(42, 42, 66, 0.95);
            border: 2px solid #4cc9f0;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 24px;
            cursor: pointer;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(10px);
        }
        
        #game-info-panel {
            position: fixed;
            top: 0;
            left: -320px;
            width: 300px;
            height: 100vh;
            background: rgba(42, 42, 66, 0.98);
            padding: 20px;
            overflow-y: auto;
            transition: left 0.3s ease;
            z-index: 999;
            border-right: 2px solid #4cc9f0;
            backdrop-filter: blur(10px);
        }
        
        #game-info-panel.active {
            left: 0;
        }
        
        #sidebar {
            display: none;
        }
        
        #game-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            position: relative;
            overflow: hidden;
            width: 100%;
        }
        
        #game-canvas {
            background: #2d5a3c;
            border: 4px solid #4cc9f0;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            transition: all 0.3s ease;
            max-width: 100%;
            max-height: 100%;
            display: block;
        }
        
        #game-canvas.indoor {
            background: #3a2c2c;
            border-color: #f72585;
        }
        
        #aim-overlay, #shotgun-preview {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .aim-cell {
            position: absolute;
            border: 3px solid #ffeb3b;
            background: rgba(255, 235, 59, 0.2);
            box-sizing: border-box;
            animation: pulse 1s infinite;
        }
        
        .shotgun-cell {
            position: absolute;
            border: 2px solid #ff9800;
            background: rgba(255, 152, 0, 0.15);
            box-sizing: border-box;
        }
        
        .player-info {
            background: rgba(51, 51, 85, 0.8);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #4cc9f0;
            backdrop-filter: blur(5px);
        }
        
        .player-info h3 {
            margin: 0 0 10px 0;
            color: #4cc9f0;
            text-align: center;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            font-size: 14px;
        }
        
        .stat-label {
            color: #aaa;
        }
        
        .stat-value {
            font-weight: bold;
            color: #fff;
        }
        
        .controls {
            background: rgba(51, 51, 85, 0.8);
            padding: 15px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            backdrop-filter: blur(5px);
        }
        
        button {
            padding: 12px;
            background: linear-gradient(135deg, #4361ee, #3a0ca3);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-weight: 600;
            user-select: none;
            transform: translateY(0);
            position: relative;
            overflow: hidden;
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.7;
            transform: none;
            box-shadow: none;
        }
        
        button.danger {
            background: linear-gradient(135deg, #f72585, #b5179e);
        }
        
        #game-status {
            background: rgba(51, 51, 85, 0.8);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            line-height: 1.6;
            backdrop-filter: blur(5px);
        }
        
        .status-active {
            color: #4cc9f0;
            font-weight: bold;
        }
        
        .status-waiting {
            color: #ff9800;
        }
        
        .status-combat {
            color: #f72585;
            font-weight: bold;
        }
        
        .turn-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.85);
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 18px;
            font-weight: bold;
            border: 2px solid currentColor;
            z-index: 100;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            animation: slideIn 0.5s ease;
        }
        
        .player-1 { color: #ff5252; }
        .player-2 { color: #2196F3; }
        .player-3 { color: #ffeb3b; }
        .player-4 { color: #e91e63; }
        
        .weapon-info {
            background: rgba(34, 34, 59, 0.9);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            border-left: 3px solid #ff9800;
        }
        
        .weapon-name {
            font-weight: bold;
            color: #ff9800;
            font-size: 16px;
        }
        
        .weapon-stats {
            font-size: 12px;
            color: #ccc;
            margin-top: 5px;
        }
        
        .health-bar-container {
            height: 20px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
            position: relative;
        }
        
        .health-bar {
            height: 100%;
            border-radius: 10px;
            transition: width 0.5s ease;
            position: relative;
        }
        
        .health-text {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        /* Mobile Controls */
        #mobile-controls {
            display: block;
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            z-index: 100;
            pointer-events: none;
        }
        
        .mobile-controls-group {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 0 20px;
            pointer-events: auto;
        }
        
        .directional-pad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            width: 180px;
            height: 180px;
        }
        
        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            width: 200px;
        }
        
        .mobile-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            font-weight: bold;
            border: 3px solid rgba(255,255,255,0.2);
            background: linear-gradient(135deg, #4361ee, #3a0ca3);
            color: white;
            user-select: none;
            transition: all 0.1s;
            margin: 0;
            padding: 0;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .mobile-btn:active {
            transform: scale(0.95);
        }
        
        .mobile-btn.warning {
            background: linear-gradient(135deg, #ff9800, #ff5722);
        }
        
        .mobile-btn.reset {
            background: linear-gradient(135deg, #ff5722, #e64a19);
        }
        
        .dice-display {
            position: absolute;
            top: -70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            padding: 15px 30px;
            border-radius: 20px;
            font-size: 24px;
            font-weight: bold;
            border: 3px solid #ff9800;
            box-shadow: 0 4px 20px rgba(255, 152, 0, 0.5);
            min-width: 140px;
            text-align: center;
            z-index: 101;
        }
        
        .center-btn {
            grid-column: 2;
            grid-row: 2;
            background: rgba(255, 255, 255, 0.1);
            color: #4cc9f0;
            font-size: 32px;
            border-color: rgba(76, 201, 240, 0.3);
        }
        
        @keyframes buttonPulse {
            0% { transform: scale(1); box-shadow: 0 4px 12px rgba(67, 97, 238, 0.4); }
            50% { transform: scale(1.05); box-shadow: 0 6px 20px rgba(67, 97, 238, 0.7); }
            100% { transform: scale(1); box-shadow: 0 4px 12px rgba(67, 97, 238, 0.4); }
        }
        
        .roll-dice-highlight {
            animation: buttonPulse 1s infinite;
            background: linear-gradient(135deg, #ff9800, #ff5722) !important;
        }
        
        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
        
        @keyframes slideIn {
            from { transform: translateX(-50%) translateY(-20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .damage-effect {
            position: absolute;
            color: #ff4444;
            font-weight: bold;
            font-size: 20px;
            pointer-events: none;
            z-index: 1000;
            animation: floatUp 1s ease-out forwards;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
        }
        
        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(0.8); opacity: 0; }
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.5s ease;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            border: 3px solid #4cc9f0;
            box-shadow: 0 10px 40px rgba(0,0,0,0.7);
        }
        
        .modal h2 {
            color: #4cc9f0;
            text-align: center;
            margin-top: 0;
        }
        
        .rule-list {
            margin: 20px 0;
            padding-left: 20px;
        }
        
        .weapon-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }
        
        .weapon-card {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid;
        }
        
        .pistol-card { border-color: #4CAF50; }
        .rifle-card { border-color: #2196F3; }
        .sniper-card { border-color: #ff9800; }
        .shotgun-card { border-color: #f44336; }
        .smg-card { border-color: #9c27b0; }
        .flamethrower-card { border-color: #ff5722; }
        
        .gear-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }
        
        .gear-card {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #4cc9f0;
        }
        
        .house-indicator {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 8px;
            border: 2px solid #f72585;
            display: none;
        }
        
        .exit-instruction {
            position: absolute;
            bottom: 80px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 8px;
            border: 2px solid #4cc9f0;
            display: none;
        }
        
        button.reset {
            background: linear-gradient(135deg, #ff5722, #e64a19);
        }
        
        @media (orientation: portrait) {
            #portrait-warning {
                display: flex;
            }
            
            #burger-menu,
            #game-container,
            #mobile-controls {
                display: none !important;
            }
        }
        
        @media (orientation: landscape) {
            #portrait-warning {
                display: none;
            }
            
            #game-canvas {
                max-width: 80vh;
                max-height: 80vh;
            }
            
            .mobile-controls-group {
                padding: 0 10px;
            }
            
            .directional-pad, .action-buttons {
                width: 160px;
            }
            
            .mobile-btn {
                width: 60px;
                height: 60px;
                font-size: 24px;
            }
            
            .dice-display {
                top: -60px;
                font-size: 20px;
                padding: 12px 24px;
            }
        }
        
        @media (min-width: 1200px) {
            body {
                flex-direction: row;
            }
            
            #sidebar {
                display: flex;
                width: 300px;
                background: rgba(42, 42, 66, 0.9);
                padding: 20px;
                flex-direction: column;
                gap: 15px;
                border-right: 2px solid #4cc9f0;
                backdrop-filter: blur(10px);
            }
            
            #burger-menu {
                display: none;
            }
            
            #mobile-controls {
                display: none;
            }
            
            #game-container {
                padding: 40px;
            }
            
            #game-canvas {
                max-width: 720px;
                max-height: 720px;
            }
        }
    </style>
</head>
<body>
    <div id="portrait-warning">
        <div class="warning-content">
            <h2>üîÑ Please Rotate Your Device</h2>
            <div class="rotate-icon">‚ÜîÔ∏è</div>
            <p>This game works best in landscape mode.</p>
        </div>
    </div>

    <div id="burger-menu" onclick="toggleGameInfo()">‚ò∞</div>
    
    <div id="game-info-panel">
        <div style="margin-bottom: 20px; text-align: right;">
            <button onclick="toggleGameInfo()" style="width: auto; padding: 5px 15px;">‚úï Close</button>
        </div>
        
        <div class="player-info">
            <h3>üéÆ BATTLE ROYALE</h3>
            <div class="health-bar-container">
                <div id="health-bar-mobile" class="health-bar" style="width: 100%; background: linear-gradient(90deg, #4CAF50, #8BC34A);"></div>
                <div class="health-text" id="health-text-mobile">100 HP</div>
            </div>
            
            <div class="stats-grid">
                <div class="stat-label">Current Player:</div>
                <div class="stat-value" id="current-player-mobile" style="color: #ff5252;">1</div>
                
                <div class="stat-label">Health:</div>
                <div class="stat-value" id="player-health-mobile">100</div>
                
                <div class="stat-label">Weapon:</div>
                <div class="stat-value" id="player-weapon-mobile">Pistol</div>
                
                <div class="stat-label">Moves Left:</div>
                <div class="stat-value" id="moves-left-mobile">0</div>
                
                <div class="stat-label">Armor:</div>
                <div class="stat-value" id="player-armor-mobile">None</div>
                
                <div class="stat-label">Gear:</div>
                <div class="stat-value" id="player-gear-mobile">-</div>
            </div>
            
            <div id="weapon-details-mobile" class="weapon-info">
                <div class="weapon-name" id="weapon-name-mobile">Pistol</div>
                <div class="weapon-stats" id="weapon-stats-mobile">Damage: 15 | Range: 5</div>
            </div>
        </div>
        
        <div id="game-status-mobile" class="controls">
            <div id="status-text-mobile">Game Starting...</div>
            <div id="mode-indicator-mobile">Mode: <span class="status-waiting">Waiting</span></div>
            <div id="location-indicator-mobile" style="margin-top: 10px; color: #4cc9f0;">Location: Outdoor</div>
        </div>
    </div>

    <div id="rules-modal" class="modal" style="display: flex;">
        <div class="modal-content">
            <h2>üéÆ BATTLE ROYALE - GAME RULES</h2>
            
            <h3>üèÜ Objective</h3>
            <p>Be the last player standing!</p>
            
            <h3>üé≤ Game Flow</h3>
            <ul class="rule-list">
                <li><strong>4 Players</strong> start in corners</li>
                <li><strong>Roll Dice</strong> to get movement points</li>
                <li><strong>Move</strong> with arrow keys or WASD</li>
                <li><strong>Aim & Shoot</strong> once per turn</li>
                <li><strong>End Turn</strong> when done</li>
            </ul>
            
            <h3>üî´ Weapon System</h3>
            <div class="weapon-list">
                <div class="weapon-card pistol-card">
                    <strong>üî´ Pistol</strong><br>
                    Damage: 15 | Range: 5
                </div>
                <div class="weapon-card rifle-card">
                    <strong>üî´ Rifle</strong><br>
                    Damage: 25 | Range: 8
                </div>
                <div class="weapon-card sniper-card">
                    <strong>üéØ Sniper</strong><br>
                    Damage: 40 | Range: 12
                </div>
                <div class="weapon-card shotgun-card">
                    <strong>üî´ Shotgun</strong><br>
                    Damage: 30 | Range: 3
                </div>
                <div class="weapon-card smg-card">
                    <strong>üî´ SMG</strong><br>
                    Damage: 20 | Range: 4
                </div>
                <div class="weapon-card flamethrower-card">
                    <strong>üî• Flamethrower</strong><br>
                    Damage: 35 | Range: 2
                </div>
            </div>
            
            <h3>üõ°Ô∏è Gear System</h3>
            <div class="gear-list">
                <div class="gear-card">
                    <strong>üõ°Ô∏è Armor</strong><br>
                    Reduces damage by 30%
                </div>
                <div class="gear-card">
                    <strong>üëü Speed Boots</strong><br>
                    +2 movement points
                </div>
                <div class="gear-card">
                    <strong>üî≠ Scope</strong><br>
                    +2 weapon range
                </div>
                <div class="gear-card">
                    <strong>üíä Medkit</strong><br>
                    Heals 50 HP
                </div>
            </div>
            
            <button onclick="document.getElementById('rules-modal').style.display='none'; game.startGame();" 
                    style="width: 100%; margin-top: 20px; padding: 15px; font-size: 18px;">
                üöÄ START GAME
            </button>
        </div>
    </div>

    <div id="house-modal" class="modal">
        <div class="modal-content">
            <h2>üè† HOUSE COMBAT</h2>
            <p id="house-message">A player has entered the house!</p>
            <div id="house-canvas-container" style="margin: 20px 0; text-align: center;">
                <canvas id="house-canvas" width="400" height="400" style="background: #3a2c2c; border: 3px solid #f72585; border-radius: 8px;"></canvas>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button onclick="game.continueHouseCombat()" style="flex: 1;">‚öîÔ∏è Continue Combat</button>
            </div>
        </div>
    </div>

    <div id="sidebar">
        <div class="player-info">
            <h3>üéÆ BATTLE ROYALE</h3>
            <div class="health-bar-container">
                <div id="health-bar" class="health-bar" style="width: 100%; background: linear-gradient(90deg, #4CAF50, #8BC34A);"></div>
                <div class="health-text" id="health-text">100 HP</div>
            </div>
            
            <div class="stats-grid">
                <div class="stat-label">Current Player:</div>
                <div class="stat-value" id="current-player" style="color: #ff5252;">1</div>
                
                <div class="stat-label">Health:</div>
                <div class="stat-value" id="player-health">100</div>
                
                <div class="stat-label">Weapon:</div>
                <div class="stat-value" id="player-weapon">Pistol</div>
                
                <div class="stat-label">Moves Left:</div>
                <div class="stat-value" id="moves-left">0</div>
                
                <div class="stat-label">Armor:</div>
                <div class="stat-value" id="player-armor">None</div>
                
                <div class="stat-label">Gear:</div>
                <div class="stat-value" id="player-gear">-</div>
            </div>
            
            <div id="weapon-details" class="weapon-info">
                <div class="weapon-name" id="weapon-name">Pistol</div>
                <div class="weapon-stats" id="weapon-stats">Damage: 15 | Range: 5</div>
            </div>
        </div>
        
        <div class="controls">
            <button id="roll-dice" onclick="game.rollDice()">
                üé≤ Roll Dice
            </button>
            
            <button id="enter-aim" onclick="game.enterAim()">
                üéØ Enter Aim Mode
            </button>
            
            <button id="shoot" onclick="game.shoot()">
                üî• Shoot
            </button>
            
            <button id="end-turn" onclick="game.endTurn()" class="danger">
                ‚è≠Ô∏è End Turn
            </button>
            
            <button id="reset-game" onclick="game.resetGame()" class="reset">
                üîÑ Reset Game
            </button>
        </div>
        
        <div id="game-status">
            <div id="status-text">Game Starting...</div>
            <div id="mode-indicator">Mode: <span class="status-waiting">Waiting</span></div>
            <div id="location-indicator" style="margin-top: 10px; color: #4cc9f0;">Location: Outdoor</div>
        </div>
    </div>
    
    <div id="game-container">
        <div id="turn-indicator" class="turn-indicator player-1" style="display: none;">
            Player 1's Turn
        </div>
        
        <canvas id="game-canvas" width="720" height="720"></canvas>
        <div id="aim-overlay"></div>
        <div id="shotgun-preview"></div>
        
        <div id="house-indicator" class="house-indicator">
            <strong>üè† In House:</strong>
            <div id="house-players"></div>
        </div>
        
        <div id="exit-instruction" class="exit-instruction">
            <strong>üö™ To Exit House:</strong>
            <div>Move onto the üö™ door tile to exit</div>
        </div>
        
        <div id="mobile-controls">
            <div id="dice-result" class="dice-display" style="display: none;">üé≤ Roll Dice</div>
            <div class="mobile-controls-group">
                <div class="directional-pad">
                    <div></div>
                    <button class="mobile-btn" onclick="game.movePlayer(0, -1)" ontouchstart="event.preventDefault(); game.movePlayer(0, -1)">‚Üë</button>
                    <div></div>
                    <button class="mobile-btn" onclick="game.movePlayer(-1, 0)" ontouchstart="event.preventDefault(); game.movePlayer(-1, 0)">‚Üê</button>
                    <button class="mobile-btn center-btn" onclick="game.enterAim()" ontouchstart="event.preventDefault(); game.enterAim()">üéØ</button>
                    <button class="mobile-btn" onclick="game.movePlayer(1, 0)" ontouchstart="event.preventDefault(); game.movePlayer(1, 0)">‚Üí</button>
                    <div></div>
                    <button class="mobile-btn" onclick="game.movePlayer(0, 1)" ontouchstart="event.preventDefault(); game.movePlayer(0, 1)">‚Üì</button>
                    <div></div>
                </div>
                
                <div class="action-buttons">
                    <button class="mobile-btn warning" id="mobile-roll-dice" onclick="game.rollDice()" ontouchstart="event.preventDefault(); game.rollDice()">üé≤</button>
                    <button class="mobile-btn" id="mobile-shoot" onclick="game.shoot()" ontouchstart="event.preventDefault(); game.shoot()">üî•</button>
                    <button class="mobile-btn" id="mobile-end-turn" onclick="game.endTurn()" ontouchstart="event.preventDefault(); game.endTurn()">‚è≠Ô∏è</button>
                    <button class="mobile-btn reset" id="mobile-reset" onclick="game.resetGame()" ontouchstart="event.preventDefault(); game.resetGame()">üîÑ</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        function toggleGameInfo() {
            const panel = document.getElementById('game-info-panel');
            panel.classList.toggle('active');
        }
        
        function updateMobileUI() {
            if (!window.game) return;
            
            const player = game.players[game.currentPlayer];
            const healthPercent = (player.hp / player.maxHp) * 100;
            
            const healthBar = document.getElementById('health-bar-mobile');
            const healthText = document.getElementById('health-text-mobile');
            
            if (healthPercent > 50) {
                healthBar.style.background = 'linear-gradient(90deg, #4CAF50, #8BC34A)';
            } else if (healthPercent > 25) {
                healthBar.style.background = 'linear-gradient(90deg, #ff9800, #ffc107)';
            } else {
                healthBar.style.background = 'linear-gradient(90deg, #f44336, #ff5252)';
            }
            
            healthBar.style.width = healthPercent + '%';
            healthText.textContent = `${player.hp} HP`;
            
            const playerColors = ['#ff5252', '#2196F3', '#ffeb3b', '#e91e63'];
            document.getElementById('current-player-mobile').textContent = game.currentPlayer + 1;
            document.getElementById('current-player-mobile').style.color = playerColors[game.currentPlayer];
            
            document.getElementById('player-health-mobile').textContent = player.hp;
            document.getElementById('player-weapon-mobile').textContent = game.weapons[player.weapon].name;
            document.getElementById('moves-left-mobile').textContent = game.movesLeft;
            document.getElementById('player-armor-mobile').textContent = player.armor ? player.armor.name : 'None';
            
            const gearEl = document.getElementById('player-gear-mobile');
            if (player.gear.length > 0) {
                gearEl.innerHTML = player.gear.map(g => g.emoji).join(' ');
            } else {
                gearEl.textContent = '-';
            }
            
            const weapon = game.weapons[player.weapon];
            let range = weapon.range;
            player.gear.forEach(g => {
                if (g.effect === 'rangeBonus') range += g.value;
            });
            
            document.getElementById('weapon-name-mobile').textContent = weapon.name;
            document.getElementById('weapon-stats-mobile').innerHTML = 
                `Damage: ${weapon.damage} | Range: ${range}`;
            
            const statusEl = document.getElementById('status-text-mobile');
            const modeEl = document.getElementById('mode-indicator-mobile');
            const locationEl = document.getElementById('location-indicator-mobile');
            
            if (game.isIndoor) {
                locationEl.innerHTML = `Location: <span class="status-combat">House ${game.currentHouse.x},${game.currentHouse.y}</span>`;
                statusEl.textContent = 'Indoor combat!';
            } else {
                locationEl.innerHTML = 'Location: <span class="status-active">Outdoor</span>';
                if (!game.aiming) {
                    modeEl.innerHTML = `Mode: <span class="${game.movesLeft > 0 ? 'status-active' : 'status-waiting'}">${game.movesLeft > 0 ? 'MOVING' : 'WAITING'}</span>`;
                    if (game.hasRolled) {
                        statusEl.textContent = game.movesLeft > 0 ? 
                            `Move (${game.movesLeft} left)` :
                            'Move complete. Aim or end turn.';
                    } else {
                        statusEl.textContent = 'Tap "Roll Dice" to move';
                    }
                } else {
                    modeEl.innerHTML = `Mode: <span class="status-active">AIMING</span>`;
                    statusEl.textContent = 'Use arrows to aim, then tap Shoot';
                }
            }
        }
        
        function showDiceResult(result) {
            const diceDisplay = document.getElementById('dice-result');
            diceDisplay.textContent = `üé≤ ${result}`;
            diceDisplay.style.display = 'block';
            
            setTimeout(() => {
                diceDisplay.style.display = 'none';
            }, 3000);
        }

        class BattleRoyaleGame {
            constructor() {
                this.GRID_SIZE = 15;
                this.TILE_SIZE = 48;
                this.PLAYER_COUNT = 4;
                
                this.currentPlayer = 0;
                this.movesLeft = 0;
                this.hasShot = false;
                this.hasRolled = false;
                this.gameActive = true;
                this.isIndoor = false;
                this.currentHouse = null;
                this.viewingHouse = null;
                
                this.aiming = false;
                this.aim = {
                    x: null,
                    y: null,
                    dx: null,
                    dy: null,
                    steps: 0
                };
                
                this.canvasRect = null;
                
                this.initAudio();
                document.getElementById('rules-modal').style.display = 'flex';
                
                this.setupMobileButtons();
                this.checkOrientation();
                
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => this.checkOrientation(), 100);
                });
                
                window.addEventListener('resize', () => {
                    this.updateCanvasPosition();
                });
            }
            
            checkOrientation() {
                const isPortrait = window.innerHeight > window.innerWidth;
                const warning = document.getElementById('portrait-warning');
                
                if (isPortrait) {
                    warning.style.display = 'flex';
                } else {
                    warning.style.display = 'none';
                    this.updateCanvasPosition();
                }
            }
            
            updateCanvasPosition() {
                if (this.canvas) {
                    this.canvasRect = this.canvas.getBoundingClientRect();
                }
            }
            
            startGame() {
                this.initCanvas();
                this.initMap();
                this.initPlayers();
                this.initWeapons();
                this.initGear();
                this.initUI();
                this.draw();
                
                this.currentPlayer = 0;
                this.movesLeft = 0;
                this.hasShot = false;
                this.hasRolled = false;
                this.aiming = false;
                
                this.updateTurnIndicator();
                this.gameLoop();
                this.updateControlStatus();
                this.updateUI();
            }
            
            resetGame() {
                if (!confirm("Are you sure you want to reset the game?")) {
                    return;
                }
                
                this.currentPlayer = 0;
                this.movesLeft = 0;
                this.hasShot = false;
                this.hasRolled = false;
                this.gameActive = true;
                this.isIndoor = false;
                this.currentHouse = null;
                this.viewingHouse = null;
                this.aiming = false;
                
                this.aimOverlay.innerHTML = '';
                this.shotgunPreview.innerHTML = '';
                
                document.querySelectorAll('.damage-effect').forEach(el => el.remove());
                
                document.getElementById('house-modal').style.display = 'none';
                document.getElementById('rules-modal').style.display = 'none';
                
                this.initMap();
                this.initPlayers();
                this.initWeapons();
                this.initGear();
                this.initUI();
                
                this.switchToOutdoorView();
                
                this.updateTurnIndicator();
                this.updateUI();
                this.draw();
                
                this.playSound(600);
                
                setTimeout(() => {
                    alert("Game has been reset! Player 1 starts.");
                }, 100);
            }
            
            initCanvas() {
                this.canvas = document.getElementById('game-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.aimOverlay = document.getElementById('aim-overlay');
                this.shotgunPreview = document.getElementById('shotgun-preview');
                
                this.updateCanvasPosition();
                
                this.canvas.addEventListener('click', () => {
                    this.canvas.focus();
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                });
                
                window.addEventListener('keydown', (e) => {
                    const keyMap = {
                        'ArrowUp': [0, -1], 'w': [0, -1],
                        'ArrowDown': [0, 1], 's': [0, 1],
                        'ArrowLeft': [-1, 0], 'a': [-1, 0],
                        'ArrowRight': [1, 0], 'd': [1, 0]
                    };
                    
                    const dir = keyMap[e.key];
                    if (!dir) return;
                    
                    e.preventDefault();
                    
                    if (this.aiming) {
                        this.moveAim(...dir);
                    } else if (this.movesLeft > 0 || this.isIndoor) {
                        this.movePlayer(...dir);
                    }
                });
            }
            
            initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Audio not supported');
                }
            }
            
            playSound(frequency, duration = 0.1, type = 'sine') {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.value = frequency;
                oscillator.type = type;
                
                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + duration);
            }
            
            initMap() {
                this.map = [];
                this.houses = [];
                
                const playerStarts = [
                    [0, this.GRID_SIZE-1],
                    [0, 0],
                    [this.GRID_SIZE-1, 0],
                    [this.GRID_SIZE-1, this.GRID_SIZE-1]
                ];
                
                const clearPaths = [];
                playerStarts.forEach(([x, y]) => {
                    clearPaths.push([x, y]);
                    
                    if (x > 0) clearPaths.push([x-1, y]);
                    if (x < this.GRID_SIZE-1) clearPaths.push([x+1, y]);
                    if (y > 0) clearPaths.push([x, y-1]);
                    if (y < this.GRID_SIZE-1) clearPaths.push([x, y+1]);
                    
                    if (x > 0 && y > 0) clearPaths.push([x-1, y-1]);
                    if (x > 0 && y < this.GRID_SIZE-1) clearPaths.push([x-1, y+1]);
                    if (x < this.GRID_SIZE-1 && y > 0) clearPaths.push([x+1, y-1]);
                    if (x < this.GRID_SIZE-1 && y < this.GRID_SIZE-1) clearPaths.push([x+1, y+1]);
                });
                
                for (let y = 0; y < this.GRID_SIZE; y++) {
                    this.map[y] = [];
                    for (let x = 0; x < this.GRID_SIZE; x++) {
                        const isOnPath = clearPaths.some(([px, py]) => px === x && py === y);
                        
                        if (isOnPath) {
                            this.map[y][x] = null;
                            continue;
                        }
                        
                        const r = Math.random();
                        if (r < 0.08) {
                            this.map[y][x] = { type: 'üå≥', blocks: true, cover: true };
                        } else if (r < 0.14) {
                            this.map[y][x] = { type: 'ü™®', blocks: true, cover: true };
                        } else if (r < 0.16) {
                            this.map[y][x] = { type: 'üè†', blocks: false, house: true };
                            this.houses.push({ 
                                x, y, 
                                indoorMap: this.createIndoorMap(),
                                playersInside: [],
                                entranceX: x,
                                entranceY: y
                            });
                        } else if (r < 0.20) {
                            this.map[y][x] = { type: 'üì¶', blocks: false, item: true };
                        } else {
                            this.map[y][x] = null;
                        }
                    }
                }
            }
            
            createIndoorMap() {
                const indoorSize = 8;
                const indoorMap = [];
                
                for (let y = 0; y < indoorSize; y++) {
                    indoorMap[y] = [];
                    for (let x = 0; x < indoorSize; x++) {
                        indoorMap[y][x] = null;
                    }
                }
                
                const doorX = Math.floor(indoorSize / 2) - 1;
                const doorY = indoorSize - 1;
                
                indoorMap[doorY][doorX] = { type: 'üö™', blocks: false, exit: true, entrance: true };
                
                for (let y = 0; y < indoorSize; y++) {
                    for (let x = 0; x < indoorSize; x++) {
                        if (x === 0 || y === 0 || x === indoorSize-1 || y === indoorSize-1) {
                            if (x === doorX && y === doorY) {
                                continue;
                            }
                            indoorMap[y][x] = { type: 'üß±', blocks: true };
                        }
                    }
                }
                
                const safeZone = [
                    [doorX, doorY],
                    [doorX, doorY - 1],
                    [doorX - 1, doorY],
                    [doorX + 1, doorY],
                    [doorX, doorY - 2],
                    [doorX - 1, doorY - 1],
                    [doorX + 1, doorY - 1],
                ];
                
                const furniture = ['üõãÔ∏è', 'üì∫', 'ü™ë', 'üõèÔ∏è'];
                const foodItems = ['üçé', 'üçó', 'ü•§'];
                
                for (let y = 1; y < indoorSize - 1; y++) {
                    for (let x = 1; x < indoorSize - 1; x++) {
                        const isSafe = safeZone.some(([sx, sy]) => sx === x && sy === y);
                        if (isSafe) continue;
                        
                        if (x === doorX && y === doorY) continue;
                        
                        const r = Math.random();
                        
                        if (r < 0.25) {
                            const furnitureType = furniture[Math.floor(Math.random() * furniture.length)];
                            indoorMap[y][x] = { type: furnitureType, blocks: true };
                        } else if (r < 0.28) {
                            const foodType = foodItems[Math.floor(Math.random() * foodItems.length)];
                            indoorMap[y][x] = { type: foodType, blocks: false, food: true, healAmount: this.getFoodHealAmount(foodType) };
                        } else if (r < 0.33) {
                            indoorMap[y][x] = { type: 'üì¶', blocks: false, item: true };
                        }
                    }
                }
                
                return indoorMap;
            }
            
            getFoodHealAmount(foodType) {
                const healAmounts = {
                    'üçé': 15,
                    'üçó': 25,
                    'ü•§': 20
                };
                return healAmounts[foodType] || 20;
            }
            
            initPlayers() {
                this.players = [
                    { 
                        x: 0, y: this.GRID_SIZE-1, 
                        hp: 100, maxHp: 100,
                        weapon: 'pistol', 
                        emoji: 'üßç‚Äç‚ôÇÔ∏è', 
                        alive: true,
                        armor: null,
                        gear: [],
                        inHouse: null,
                        indoorPos: null
                    },
                    { 
                        x: 0, y: 0, 
                        hp: 100, maxHp: 100,
                        weapon: 'pistol', 
                        emoji: 'üßç‚Äç‚ôÄÔ∏è', 
                        alive: true,
                        armor: null,
                        gear: [],
                        inHouse: null,
                        indoorPos: null
                    },
                    { 
                        x: this.GRID_SIZE-1, y: 0, 
                        hp: 100, maxHp: 100,
                        weapon: 'pistol', 
                        emoji: 'üßë', 
                        alive: true,
                        armor: null,
                        gear: [],
                        inHouse: null,
                        indoorPos: null
                    },
                    { 
                        x: this.GRID_SIZE-1, y: this.GRID_SIZE-1, 
                        hp: 100, maxHp: 100,
                        weapon: 'pistol', 
                        emoji: 'üßî', 
                        alive: true,
                        armor: null,
                        gear: [],
                        inHouse: null,
                        indoorPos: null
                    }
                ];
            }
            
            initWeapons() {
                this.weapons = {
                    pistol: { 
                        name: 'Pistol', 
                        damage: 15, 
                        range: 5, 
                        emoji: 'üî´',
                        type: 'linear'
                    },
                    rifle: { 
                        name: 'Rifle', 
                        damage: 25, 
                        range: 8, 
                        emoji: 'üî´',
                        type: 'linear'
                    },
                    sniper: { 
                        name: 'Sniper', 
                        damage: 40, 
                        range: 12, 
                        emoji: 'üéØ',
                        type: 'linear'
                    },
                    shotgun: { 
                        name: 'Shotgun', 
                        damage: 30, 
                        range: 3, 
                        emoji: 'üî´',
                        type: 'shotgun'
                    },
                    smg: { 
                        name: 'SMG', 
                        damage: 20, 
                        range: 4, 
                        emoji: 'üî´',
                        type: 'rapid'
                    },
                    flamethrower: { 
                        name: 'Flamethrower', 
                        damage: 35, 
                        range: 2, 
                        emoji: 'üî•',
                        type: 'flame'
                    }
                };
            }
            
            initGear() {
                this.gearTypes = {
                    armor: {
                        name: 'Armor',
                        emoji: 'üõ°Ô∏è',
                        effect: 'damageReduction',
                        value: 0.3
                    },
                    speedBoots: {
                        name: 'Speed Boots',
                        emoji: 'üëü',
                        effect: 'movementBonus',
                        value: 2
                    },
                    scope: {
                        name: 'Scope',
                        emoji: 'üî≠',
                        effect: 'rangeBonus',
                        value: 2
                    },
                    medkit: {
                        name: 'Medkit',
                        emoji: 'üíä',
                        effect: 'heal',
                        value: 50
                    }
                };
            }
            
            initUI() {
                this.updateUI();
                this.updateWeaponInfo();
                this.updateControlStatus();
            }
            
            setupMobileButtons() {
                setInterval(() => {
                    if (!this.gameActive) return;
                    
                    const rollBtn = document.getElementById('mobile-roll-dice');
                    const shootBtn = document.getElementById('mobile-shoot');
                    
                    if (rollBtn) {
                        rollBtn.disabled = this.hasRolled || this.isIndoor || this.aiming;
                        if (!this.hasRolled && !this.isIndoor && !this.aiming && this.gameActive) {
                            rollBtn.classList.add('roll-dice-highlight');
                        } else {
                            rollBtn.classList.remove('roll-dice-highlight');
                        }
                    }
                    
                    if (shootBtn) {
                        shootBtn.disabled = !this.aiming || this.hasShot;
                    }
                }, 100);
            }
            
            updateControlStatus() {
                updateMobileUI();
            }
            
            updateUI() {
                const player = this.players[this.currentPlayer];
                
                const healthPercent = (player.hp / player.maxHp) * 100;
                const healthBar = document.getElementById('health-bar');
                const healthText = document.getElementById('health-text');
                
                if (healthPercent > 50) {
                    healthBar.style.background = 'linear-gradient(90deg, #4CAF50, #8BC34A)';
                } else if (healthPercent > 25) {
                    healthBar.style.background = 'linear-gradient(90deg, #ff9800, #ffc107)';
                } else {
                    healthBar.style.background = 'linear-gradient(90deg, #f44336, #ff5252)';
                }
                
                healthBar.style.width = healthPercent + '%';
                healthText.textContent = `${player.hp} HP`;
                
                const playerColors = ['#ff5252', '#2196F3', '#ffeb3b', '#e91e63'];
                document.getElementById('current-player').textContent = this.currentPlayer + 1;
                document.getElementById('current-player').style.color = playerColors[this.currentPlayer];
                
                document.getElementById('player-health').textContent = player.hp;
                document.getElementById('player-weapon').textContent = this.weapons[player.weapon].name;
                document.getElementById('moves-left').textContent = this.movesLeft;
                document.getElementById('player-armor').textContent = player.armor ? player.armor.name : 'None';
                
                const gearEl = document.getElementById('player-gear');
                if (player.gear.length > 0) {
                    gearEl.innerHTML = player.gear.map(g => g.emoji).join(' ');
                } else {
                    gearEl.textContent = '-';
                }
                
                const rollDiceBtn = document.getElementById('roll-dice');
                if (rollDiceBtn) {
                    rollDiceBtn.disabled = this.hasRolled || this.isIndoor;
                    
                    if (!this.hasRolled && !this.isIndoor && this.gameActive) {
                        rollDiceBtn.classList.add('roll-dice-highlight');
                    } else {
                        rollDiceBtn.classList.remove('roll-dice-highlight');
                    }
                }
                
                const enterAimBtn = document.getElementById('enter-aim');
                const shootBtn = document.getElementById('shoot');
                
                if (enterAimBtn) enterAimBtn.disabled = this.hasShot || this.aiming;
                if (shootBtn) shootBtn.disabled = !this.aiming || this.hasShot;
                
                const statusEl = document.getElementById('status-text');
                const modeEl = document.getElementById('mode-indicator');
                const locationEl = document.getElementById('location-indicator');
                
                if (this.isIndoor) {
                    if (locationEl) locationEl.innerHTML = `Location: <span class="status-combat">House ${this.currentHouse.x},${this.currentHouse.y}</span>`;
                    if (statusEl) statusEl.textContent = 'Indoor combat!';
                    
                    document.getElementById('exit-instruction').style.display = 'block';
                } else {
                    if (locationEl) locationEl.innerHTML = 'Location: <span class="status-active">Outdoor</span>';
                    document.getElementById('exit-instruction').style.display = 'none';
                    
                    if (!this.aiming) {
                        if (modeEl) modeEl.innerHTML = `Mode: <span class="${this.movesLeft > 0 ? 'status-active' : 'status-waiting'}">${this.movesLeft > 0 ? 'MOVING' : 'WAITING'}</span>`;
                        if (statusEl) {
                            if (this.hasRolled) {
                                statusEl.textContent = this.movesLeft > 0 ? 
                                    `Use arrow keys/WASD to move (${this.movesLeft} moves left)` :
                                    'Movement complete. You can aim or end turn.';
                            } else {
                                statusEl.textContent = 'Click "Roll Dice" to start moving';
                            }
                        }
                    } else {
                        if (modeEl) modeEl.innerHTML = `Mode: <span class="status-active">AIMING</span>`;
                        if (statusEl) statusEl.textContent = 'Use arrow keys/WASD to aim, then click "Shoot"';
                    }
                }
                
                this.updateHouseIndicator();
                this.updateWeaponInfo();
                updateMobileUI();
            }
            
            updateWeaponInfo() {
                const player = this.players[this.currentPlayer];
                const weapon = this.weapons[player.weapon];
                
                let range = weapon.range;
                player.gear.forEach(g => {
                    if (g.effect === 'rangeBonus') range += g.value;
                });
                
                const weaponNameEl = document.getElementById('weapon-name');
                const weaponStatsEl = document.getElementById('weapon-stats');
                
                if (weaponNameEl) weaponNameEl.textContent = weapon.name;
                if (weaponStatsEl) weaponStatsEl.innerHTML = 
                    `Damage: ${weapon.damage} | Range: ${range}`;
                
                this.updateShotgunPreview();
            }
            
            updateHouseIndicator() {
                const indicator = document.getElementById('house-indicator');
                const playersEl = document.getElementById('house-players');
                
                let anyHouseOccupied = false;
                let houseInfo = '';
                
                this.houses.forEach(house => {
                    if (house.playersInside.length > 0) {
                        anyHouseOccupied = true;
                        houseInfo += `<div style="margin: 5px 0;">üè† (${house.x},${house.y}): `;
                        house.playersInside.forEach(pid => {
                            const p = this.players[pid];
                            houseInfo += `<span style="color: ${this.getPlayerColor(pid)}">P${pid+1}</span> `;
                        });
                        houseInfo += '</div>';
                    }
                });
                
                if (anyHouseOccupied) {
                    indicator.style.display = 'block';
                    playersEl.innerHTML = houseInfo;
                } else {
                    indicator.style.display = 'none';
                }
            }
            
            updateTurnIndicator() {
                const indicator = document.getElementById('turn-indicator');
                const colors = ['player-1', 'player-2', 'player-3', 'player-4'];
                
                indicator.textContent = `Player ${this.currentPlayer + 1}'s Turn`;
                indicator.className = `turn-indicator ${colors[this.currentPlayer]}`;
                indicator.style.display = 'block';
                
                setTimeout(() => {
                    indicator.style.display = 'none';
                }, 2000);
            }
            
            showDamageEffect(x, y, damage) {
                const effect = document.createElement('div');
                effect.className = 'damage-effect';
                effect.textContent = `-${damage}`;
                
                let posX, posY;
                if (this.isIndoor) {
                    const offsetX = (this.GRID_SIZE - 8) * this.TILE_SIZE / 2;
                    const offsetY = (this.GRID_SIZE - 8) * this.TILE_SIZE / 2;
                    posX = x * this.TILE_SIZE + offsetX + this.TILE_SIZE / 2;
                    posY = y * this.TILE_SIZE + offsetY;
                } else {
                    posX = x * this.TILE_SIZE + this.TILE_SIZE / 2;
                    posY = y * this.TILE_SIZE;
                }
                
                effect.style.left = `${posX}px`;
                effect.style.top = `${posY}px`;
                
                document.getElementById('game-container').appendChild(effect);
                
                setTimeout(() => effect.remove(), 1000);
            }
            
            rollDice() {
                if (this.hasRolled || this.isIndoor || this.aiming) return;
                
                const dice1 = Math.floor(Math.random() * 6) + 1;
                const dice2 = Math.floor(Math.random() * 6) + 1;
                const total = dice1 + dice2;
                this.movesLeft = total;
                this.hasRolled = true;
                
                const player = this.players[this.currentPlayer];
                player.gear.forEach(g => {
                    if (g.effect === 'movementBonus') {
                        this.movesLeft += g.value;
                    }
                });
                
                showDiceResult(`${dice1}+${dice2}=${this.movesLeft}`);
                
                this.playSound(800);
                this.updateUI();
            }
            
            movePlayer(dx, dy) {
                if (this.aiming) {
                    this.moveAim(dx, dy);
                    return;
                }
                
                const player = this.players[this.currentPlayer];
                
                if (this.isIndoor) {
                    this.movePlayerIndoor(player, dx, dy);
                } else {
                    this.movePlayerOutdoor(player, dx, dy);
                }
            }
            
            movePlayerOutdoor(player, dx, dy) {
                if (this.movesLeft <= 0 && !this.isIndoor) return;
                
                const newX = player.x + dx;
                const newY = player.y + dy;
                
                if (newX < 0 || newY < 0 || newX >= this.GRID_SIZE || newY >= this.GRID_SIZE) {
                    return;
                }
                
                const tile = this.map[newY][newX];
                if (!tile) {
                    if (this.players.some(p => p.alive && p !== player && p.x === newX && p.y === newY && !p.inHouse)) {
                        return;
                    }
                    
                    player.x = newX;
                    player.y = newY;
                    if (!this.isIndoor) this.movesLeft--;
                    this.playSound(500);
                } else if (tile.blocks) {
                    return;
                } else if (tile.house) {
                    this.enterHouse(player, newX, newY);
                    return;
                } else if (tile.item) {
                    player.x = newX;
                    player.y = newY;
                    if (!this.isIndoor) this.movesLeft--;
                    this.pickupItem(newX, newY);
                    this.playSound(600);
                }
                
                this.updateUI();
                this.draw();
            }
            
            movePlayerIndoor(player, dx, dy) {
                if (!player.indoorPos) return;
                
                const house = this.currentHouse;
                const newX = player.indoorPos.x + dx;
                const newY = player.indoorPos.y + dy;
                
                if (newX < 0 || newY < 0 || newX >= 8 || newY >= 8) {
                    return;
                }
                
                const tile = house.indoorMap[newY][newX];
                if (!tile) {
                    const otherPlayer = this.players.find(p => 
                        p.alive && 
                        p !== player && 
                        p.inHouse === player.inHouse &&
                        p.indoorPos && 
                        p.indoorPos.x === newX && 
                        p.indoorPos.y === newY
                    );
                    
                    if (otherPlayer) {
                        return;
                    }
                    
                    player.indoorPos.x = newX;
                    player.indoorPos.y = newY;
                    this.playSound(500);
                } else if (tile.blocks) {
                    return;
                } else if (tile.exit) {
                    this.exitHouse(player);
                    return;
                } else if (tile.item) {
                    player.indoorPos.x = newX;
                    player.indoorPos.y = newY;
                    this.pickupIndoorItem(newX, newY);
                    this.playSound(600);
                } else if (tile.food) {
                    player.indoorPos.x = newX;
                    player.indoorPos.y = newY;
                    this.eatFood(newX, newY, tile);
                    this.playSound(700);
                }
                
                this.updateUI();
                this.drawIndoor();
            }
            
            enterHouse(player, houseX, houseY) {
                const house = this.houses.find(h => h.x === houseX && h.y === houseY);
                if (!house) return;
                
                const doorX = Math.floor(8 / 2) - 1;
                const doorY = 7;
                
                player.inHouse = house;
                player.indoorPos = { x: doorX, y: doorY };
                const playerIndex = this.players.indexOf(player);
                house.playersInside.push(playerIndex);
                
                this.playSound(700);
                
                if (house.playersInside.length > 1) {
                    this.startIndoorCombat(house);
                } else {
                    this.switchToIndoorView(house);
                    alert(`üè† Player ${playerIndex + 1} entered the house!`);
                }
            }
            
            switchToIndoorView(house) {
                this.isIndoor = true;
                this.currentHouse = house;
                this.viewingHouse = house;
                this.canvas.classList.add('indoor');
                this.updateUI();
                this.drawIndoor();
            }
            
            switchToOutdoorView() {
                this.isIndoor = false;
                this.currentHouse = null;
                this.viewingHouse = null;
                this.canvas.classList.remove('indoor');
                document.getElementById('house-modal').style.display = 'none';
                this.updateUI();
                this.draw();
            }
            
            startIndoorCombat(house) {
                this.switchToIndoorView(house);
                
                const houseModal = document.getElementById('house-modal');
                const houseMessage = document.getElementById('house-message');
                
                const playerNames = house.playersInside.map(pid => 
                    `<span style="color: ${this.getPlayerColor(pid)}">Player ${pid + 1}</span>`
                ).join(' and ');
                
                houseMessage.innerHTML = `${playerNames} are fighting inside the house!`;
                
                houseModal.style.display = 'flex';
                
                this.drawIndoorCombat();
            }
            
            exitHouse(player) {
                if (!player) {
                    player = this.players[this.currentPlayer];
                }
                
                const house = player.inHouse;
                if (!house) return;
                
                const playerIndex = this.players.indexOf(player);
                const housePlayerIndex = house.playersInside.indexOf(playerIndex);
                if (housePlayerIndex > -1) {
                    house.playersInside.splice(housePlayerIndex, 1);
                }
                
                player.x = house.entranceX;
                player.y = house.entranceY;
                player.inHouse = null;
                player.indoorPos = null;
                
                this.playSound(600);
                
                this.updateViewForCurrentPlayer();
                
                alert(`üö™ Player ${playerIndex + 1} exited the house!`);
                
                this.updateUI();
            }
            
            updateViewForCurrentPlayer() {
                const currentPlayer = this.players[this.currentPlayer];
                
                if (currentPlayer.inHouse) {
                    this.switchToIndoorView(currentPlayer.inHouse);
                } else {
                    this.switchToOutdoorView();
                }
            }
            
            continueHouseCombat() {
                document.getElementById('house-modal').style.display = 'none';
                this.updateUI();
                this.drawIndoor();
            }
            
            eatFood(x, y, tile) {
                const player = this.players[this.currentPlayer];
                const house = this.currentHouse;
                
                house.indoorMap[y][x] = null;
                
                const healAmount = tile.healAmount || 20;
                const oldHp = player.hp;
                player.hp = Math.min(player.maxHp, player.hp + healAmount);
                const actualHeal = player.hp - oldHp;
                
                alert(`üçΩÔ∏è Found ${tile.type}! Healed ${actualHeal} HP. Current HP: ${player.hp}`);
                this.playSound(800);
            }
            
            pickupItem(x, y) {
                const player = this.players[this.currentPlayer];
                const tile = this.map[y][x];
                
                if (!tile || !tile.item) return;
                
                this.map[y][x] = null;
                
                const isWeapon = Math.random() < 0.7;
                
                if (isWeapon) {
                    const weaponKeys = Object.keys(this.weapons);
                    const currentWeapon = player.weapon;
                    const availableWeapons = weaponKeys.filter(w => w !== currentWeapon);
                    
                    if (availableWeapons.length === 0) return;
                    
                    const newWeapon = availableWeapons[Math.floor(Math.random() * availableWeapons.length)];
                    const weapon = this.weapons[newWeapon];
                    
                    const confirmPickup = confirm(
                        `üéÅ WEAPON CRATE!\n\nCurrent: ${this.weapons[currentWeapon].name}\nFound: ${weapon.name}\n\nDamage: ${weapon.damage}\nRange: ${weapon.range}\n\nTake the new weapon?`
                    );
                    
                    if (confirmPickup) {
                        player.weapon = newWeapon;
                        alert(`Equipped ${weapon.name}!`);
                        this.playSound(900);
                    } else {
                        this.map[y][x] = tile;
                    }
                } else {
                    const gearKeys = Object.keys(this.gearTypes);
                    const newGearKey = gearKeys[Math.floor(Math.random() * gearKeys.length)];
                    const newGear = this.gearTypes[newGearKey];
                    
                    if (newGearKey === 'medkit') {
                        player.hp = Math.min(player.maxHp, player.hp + newGear.value);
                        alert(`üíä Found Medkit! Healed ${newGear.value} HP. Current HP: ${player.hp}`);
                        this.playSound(800);
                    } else {
                        const confirmPickup = confirm(
                            `üéÅ GEAR CRATE!\n\nFound: ${newGear.emoji} ${newGear.name}\n\nTake this gear?`
                        );
                        
                        if (confirmPickup) {
                            if (newGearKey === 'armor') {
                                player.armor = newGear;
                            } else {
                                player.gear.push(newGear);
                            }
                            alert(`Equipped ${newGear.emoji} ${newGear.name}!`);
                            this.playSound(800);
                        } else {
                            this.map[y][x] = tile;
                        }
                    }
                }
                
                this.updateWeaponInfo();
            }
            
            pickupIndoorItem(x, y) {
                const player = this.players[this.currentPlayer];
                const house = this.currentHouse;
                const tile = house.indoorMap[y][x];
                
                if (!tile || !tile.item) return;
                
                house.indoorMap[y][x] = null;
                
                const isWeapon = Math.random() < 0.7;
                
                if (isWeapon) {
                    const weaponKeys = Object.keys(this.weapons);
                    const currentWeapon = player.weapon;
                    const availableWeapons = weaponKeys.filter(w => w !== currentWeapon);
                    
                    if (availableWeapons.length === 0) return;
                    
                    const newWeapon = availableWeapons[Math.floor(Math.random() * availableWeapons.length)];
                    const weapon = this.weapons[newWeapon];
                    
                    const confirmPickup = confirm(
                        `üì¶ HOUSE WEAPON CRATE!\n\nCurrent: ${this.weapons[currentWeapon].name}\nFound: ${weapon.name}\n\nDamage: ${weapon.damage}\nRange: ${weapon.range}\n\nTake the new weapon?`
                    );
                    
                    if (confirmPickup) {
                        player.weapon = newWeapon;
                        alert(`Equipped ${weapon.name} from house chest!`);
                        this.playSound(900);
                    } else {
                        house.indoorMap[y][x] = tile;
                    }
                } else {
                    const gearKeys = Object.keys(this.gearTypes);
                    const newGearKey = gearKeys[Math.floor(Math.random() * gearKeys.length)];
                    const newGear = this.gearTypes[newGearKey];
                    
                    if (newGearKey === 'medkit') {
                        player.hp = Math.min(player.maxHp, player.hp + newGear.value);
                        alert(`üíä Found Medkit in chest! Healed ${newGear.value} HP. Current HP: ${player.hp}`);
                        this.playSound(800);
                    } else {
                        const confirmPickup = confirm(
                            `üì¶ HOUSE GEAR CRATE!\n\nFound: ${newGear.emoji} ${newGear.name}\n\nTake this gear?`
                        );
                        
                        if (confirmPickup) {
                            if (newGearKey === 'armor') {
                                player.armor = newGear;
                            } else {
                                player.gear.push(newGear);
                            }
                            alert(`Equipped ${newGear.emoji} ${newGear.name} from house chest!`);
                            this.playSound(800);
                        } else {
                            house.indoorMap[y][x] = tile;
                        }
                    }
                }
                
                this.updateWeaponInfo();
            }
            
            enterAim() {
                if (this.aiming || this.hasShot) return;
                
                const player = this.players[this.currentPlayer];
                this.aiming = true;
                
                if (this.isIndoor && player.indoorPos) {
                    this.aim = {
                        x: player.indoorPos.x,
                        y: player.indoorPos.y,
                        dx: null,
                        dy: null,
                        steps: 0
                    };
                } else {
                    this.aim = {
                        x: player.x,
                        y: player.y,
                        dx: null,
                        dy: null,
                        steps: 0
                    };
                }
                
                this.updateAimCursor();
                this.playSound(600);
                this.updateUI();
            }
            
            moveAim(dx, dy) {
                if (!this.aiming) return;
                
                const player = this.players[this.currentPlayer];
                const weapon = this.weapons[player.weapon];
                
                let range = weapon.range;
                player.gear.forEach(g => {
                    if (g.effect === 'rangeBonus') range += g.value;
                });
                
                if (this.aim.dx === null && this.aim.dy === null) {
                    this.aim.dx = dx;
                    this.aim.dy = dy;
                }
                
                if (dx !== this.aim.dx || dy !== this.aim.dy) return;
                
                if (this.aim.steps >= range) return;
                
                const newX = this.aim.x + dx;
                const newY = this.aim.y + dy;
                
                let maxX, maxY;
                if (this.isIndoor) {
                    maxX = maxY = 8;
                } else {
                    maxX = maxY = this.GRID_SIZE;
                }
                
                if (newX < 0 || newY < 0 || newX >= maxX || newY >= maxY) {
                    return;
                }
                
                this.aim.x = newX;
                this.aim.y = newY;
                this.aim.steps++;
                
                this.updateAimCursor();
                this.updateShotgunPreview();
                this.playSound(400);
            }
            
            updateAimCursor() {
                this.aimOverlay.innerHTML = '';
                
                if (!this.aiming) return;
                
                let x, y, tileSize;
                if (this.isIndoor) {
                    const indoorOffsetX = (this.GRID_SIZE - 8) * this.TILE_SIZE / 2;
                    const indoorOffsetY = (this.GRID_SIZE - 8) * this.TILE_SIZE / 2;
                    x = this.aim.x * this.TILE_SIZE + indoorOffsetX;
                    y = this.aim.y * this.TILE_SIZE + indoorOffsetY;
                    tileSize = this.TILE_SIZE;
                } else {
                    x = this.aim.x * this.TILE_SIZE;
                    y = this.aim.y * this.TILE_SIZE;
                    tileSize = this.TILE_SIZE;
                }
                
                const cursor = document.createElement('div');
                cursor.className = 'aim-cell';
                cursor.style.left = x + 'px';
                cursor.style.top = y + 'px';
                cursor.style.width = tileSize + 'px';
                cursor.style.height = tileSize + 'px';
                
                this.aimOverlay.appendChild(cursor);
            }
            
            updateShotgunPreview() {
                this.shotgunPreview.innerHTML = '';
                
                if (!this.aiming) return;
                
                const player = this.players[this.currentPlayer];
                const weapon = this.weapons[player.weapon];
                
                if (weapon.type !== 'shotgun' || this.aim.dx === null) return;
                
                const patterns = this.getShotgunPattern(this.aim.dx, this.aim.dy);
                
                patterns.forEach(([dx, dy]) => {
                    const x = this.aim.x + dx;
                    const y = this.aim.y + dy;
                    
                    let maxX, maxY;
                    if (this.isIndoor) {
                        maxX = maxY = 8;
                    } else {
                        maxX = maxY = this.GRID_SIZE;
                    }
                    
                    if (x < 0 || y < 0 || x >= maxX || y >= maxY) return;
                    
                    let posX, posY, tileSize;
                    if (this.isIndoor) {
                        const indoorOffsetX = (this.GRID_SIZE - 8) * this.TILE_SIZE / 2;
                        const indoorOffsetY = (this.GRID_SIZE - 8) * this.TILE_SIZE / 2;
                        posX = x * this.TILE_SIZE + indoorOffsetX;
                        posY = y * this.TILE_SIZE + indoorOffsetY;
                        tileSize = this.TILE_SIZE;
                    } else {
                        posX = x * this.TILE_SIZE;
                        posY = y * this.TILE_SIZE;
                        tileSize = this.TILE_SIZE;
                    }
                    
                    const cell = document.createElement('div');
                    cell.className = 'shotgun-cell';
                    cell.style.left = posX + 'px';
                    cell.style.top = posY + 'px';
                    cell.style.width = tileSize + 'px';
                    cell.style.height = tileSize + 'px';
                    
                    this.shotgunPreview.appendChild(cell);
                });
            }
            
            getShotgunPattern(dx, dy) {
                if (dx === 0) {
                    return [[0, dy], [-1, dy], [1, dy]];
                } else if (dy === 0) {
                    return [[dx, 0], [dx, -1], [dx, 1]];
                }
                return [[dx, dy]];
            }
            
            shoot() {
                if (!this.aiming || this.hasShot) return;
                
                const shooter = this.players[this.currentPlayer];
                const weapon = this.weapons[shooter.weapon];
                
                if (weapon.type === 'shotgun') {
                    this.fireShotgun(shooter, weapon);
                } else if (weapon.type === 'rapid') {
                    this.fireRapid(shooter, weapon);
                } else if (weapon.type === 'flame') {
                    this.fireFlamethrower(shooter, weapon);
                } else {
                    this.fireLinear(shooter, weapon);
                }
                
                this.hasShot = true;
                this.aiming = false;
                this.aimOverlay.innerHTML = '';
                this.shotgunPreview.innerHTML = '';
                
                this.updateUI();
                if (this.isIndoor) {
                    this.drawIndoor();
                } else {
                    this.draw();
                }
            }
            
            fireLinear(shooter, weapon) {
                const target = this.findTargetAt(shooter, this.aim.x, this.aim.y);
                
                if (target) {
                    if (this.checkLineOfSight(shooter, target)) {
                        this.applyDamage(shooter, target, weapon.damage);
                    } else {
                        alert('Shot blocked by cover!');
                        this.playSound(200, 0.1, 'square');
                    }
                } else {
                    alert('No target at aimed position!');
                    this.playSound(200, 0.1, 'square');
                }
            }
            
            fireShotgun(shooter, weapon) {
                if (this.aim.dx === null) return;
                
                const patterns = this.getShotgunPattern(this.aim.dx, this.aim.dy);
                let hitCount = 0;
                
                patterns.forEach(([dx, dy]) => {
                    const targetX = this.aim.x + dx;
                    const targetY = this.aim.y + dy;
                    
                    const target = this.findTargetAt(shooter, targetX, targetY);
                    if (target && this.checkLineOfSight(shooter, target)) {
                        this.applyDamage(shooter, target, Math.floor(weapon.damage / 2));
                        hitCount++;
                    }
                });
                
                if (hitCount > 0) {
                    this.playSound(300, 0.2, 'sawtooth');
                } else {
                    alert('Shotgun missed!');
                    this.playSound(200, 0.1, 'square');
                }
            }
            
            fireRapid(shooter, weapon) {
                const target = this.findTargetAt(shooter, this.aim.x, this.aim.y);
                
                if (target && this.checkLineOfSight(shooter, target)) {
                    this.applyDamage(shooter, target, weapon.damage);
                    setTimeout(() => {
                        this.applyDamage(shooter, target, weapon.damage);
                    }, 200);
                    this.playSound(400, 0.3, 'sawtooth');
                } else {
                    alert('SMG missed!');
                    this.playSound(200, 0.1, 'square');
                }
            }
            
            fireFlamethrower(shooter, weapon) {
                const target = this.findTargetAt(shooter, this.aim.x, this.aim.y);
                
                if (target) {
                    this.applyDamage(shooter, target, weapon.damage);
                    this.playSound(200, 0.4, 'sawtooth');
                } else {
                    alert('Flamethrower missed!');
                    this.playSound(200, 0.1, 'square');
                }
            }
            
            findTargetAt(shooter, x, y) {
                if (this.isIndoor) {
                    return this.players.find(p => 
                        p.alive && 
                        p !== shooter && 
                        p.inHouse === shooter.inHouse &&
                        p.indoorPos && 
                        p.indoorPos.x === x && 
                        p.indoorPos.y === y
                    );
                } else {
                    return this.players.find(p => 
                        p.alive && 
                        p !== shooter && 
                        !p.inHouse &&
                        p.x === x && 
                        p.y === y
                    );
                }
            }
            
            checkLineOfSight(shooter, target) {
                if (this.weapons[shooter.weapon].type === 'flame') {
                    return true;
                }
                
                let x1, y1, x2, y2, map;
                
                if (this.isIndoor) {
                    x1 = shooter.indoorPos.x;
                    y1 = shooter.indoorPos.y;
                    x2 = target.indoorPos.x;
                    y2 = target.indoorPos.y;
                    map = this.currentHouse.indoorMap;
                } else {
                    x1 = shooter.x;
                    y1 = shooter.y;
                    x2 = target.x;
                    y2 = target.y;
                    map = this.map;
                }
                
                const dx = Math.abs(x2 - x1);
                const dy = Math.abs(y2 - y1);
                const sx = (x1 < x2) ? 1 : -1;
                const sy = (y1 < y2) ? 1 : -1;
                let err = dx - dy;
                
                let x = x1;
                let y = y1;
                
                while (true) {
                    if (x !== x1 || y !== y1) {
                        if (map[y] && map[y][x] && map[y][x].blocks) {
                            return false;
                        }
                    }
                    
                    if (x === x2 && y === y2) break;
                    
                    const e2 = 2 * err;
                    if (e2 > -dy) {
                        err -= dy;
                        x += sx;
                    }
                    if (e2 < dx) {
                        err += dx;
                        y += sy;
                    }
                }
                
                return true;
            }
            
            applyDamage(shooter, target, baseDamage) {
                let finalDamage = baseDamage;
                if (target.armor && target.armor.effect === 'damageReduction') {
                    finalDamage = Math.floor(baseDamage * (1 - target.armor.value));
                }
                
                target.hp -= finalDamage;
                
                if (this.isIndoor && target.indoorPos) {
                    this.showDamageEffect(
                        target.indoorPos.x,
                        target.indoorPos.y,
                        finalDamage
                    );
                } else {
                    this.showDamageEffect(
                        target.x,
                        target.y,
                        finalDamage
                    );
                }
                
                this.playSound(400 + finalDamage * 2);
                
                if (target.hp <= 0) {
                    target.alive = false;
                    target.hp = 0;
                    
                    if (target.inHouse) {
                        const house = target.inHouse;
                        const playerIndex = this.players.indexOf(target);
                        const houseIndex = house.playersInside.indexOf(playerIndex);
                        if (houseIndex > -1) {
                            house.playersInside.splice(houseIndex, 1);
                        }
                        target.inHouse = null;
                        target.indoorPos = null;
                        
                        if (house.playersInside.length === 0 && this.isIndoor && this.currentHouse === house) {
                            this.switchToOutdoorView();
                        }
                    }
                    
                    const shooterIndex = this.players.indexOf(shooter);
                    const targetIndex = this.players.indexOf(target);
                    alert(`üéØ Player ${shooterIndex + 1} eliminated Player ${targetIndex + 1}!`);
                    
                    const alivePlayers = this.players.filter(p => p.alive);
                    if (alivePlayers.length === 1) {
                        const winnerIndex = this.players.findIndex(p => p.alive);
                        alert(`üéâ üèÜ Player ${winnerIndex + 1} wins the game! üèÜ üéâ`);
                        this.gameActive = false;
                    }
                }
            }
            
            endTurn() {
                if (!confirm("Are you sure you want to end your turn?")) return;
                
                this.movesLeft = 0;
                this.hasShot = false;
                this.hasRolled = false;
                this.aiming = false;
                this.aim = {
                    x: null,
                    y: null,
                    dx: null,
                    dy: null,
                    steps: 0
                };
                this.aimOverlay.innerHTML = '';
                this.shotgunPreview.innerHTML = '';
                
                let attempts = 0;
                let newPlayerIndex = this.currentPlayer;
                do {
                    newPlayerIndex = (newPlayerIndex + 1) % this.PLAYER_COUNT;
                    attempts++;
                    if (attempts > this.PLAYER_COUNT) {
                        this.gameActive = false;
                        break;
                    }
                } while (!this.players[newPlayerIndex].alive && this.gameActive);
                
                if (this.gameActive) {
                    this.currentPlayer = newPlayerIndex;
                    
                    this.updateViewForCurrentPlayer();
                    
                    this.updateTurnIndicator();
                    this.updateUI();
                    
                    this.playSound(700);
                }
            }
            
            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                for (let y = 0; y < this.GRID_SIZE; y++) {
                    for (let x = 0; x < this.GRID_SIZE; x++) {
                        const tile = this.map[y][x];
                        
                        this.ctx.fillStyle = '#2d5a3c';
                        this.ctx.fillRect(
                            x * this.TILE_SIZE, 
                            y * this.TILE_SIZE, 
                            this.TILE_SIZE, 
                            this.TILE_SIZE
                        );
                        
                        this.ctx.strokeStyle = '#3a7d44';
                        this.ctx.strokeRect(
                            x * this.TILE_SIZE, 
                            y * this.TILE_SIZE, 
                            this.TILE_SIZE, 
                            this.TILE_SIZE
                        );
                        
                        if (tile) {
                            this.ctx.font = `${this.TILE_SIZE * 0.6}px Arial`;
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            
                            if (tile.type === 'üå≥') this.ctx.fillStyle = '#2e7d32';
                            else if (tile.type === 'ü™®') this.ctx.fillStyle = '#757575';
                            else if (tile.type === 'üè†') this.ctx.fillStyle = '#8d6e63';
                            else if (tile.type === 'üì¶') this.ctx.fillStyle = '#ffd700';
                            
                            this.ctx.fillText(
                                tile.type,
                                x * this.TILE_SIZE + this.TILE_SIZE / 2,
                                y * this.TILE_SIZE + this.TILE_SIZE / 2
                            );
                        }
                    }
                }
                
                this.players.forEach((player, index) => {
                    if (!player.alive || player.inHouse) return;
                    
                    this.drawPlayer(player, index, player.x, player.y);
                });
            }
            
            drawIndoor() {
                if (!this.currentHouse) return;
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                const indoorSize = 8;
                const offsetX = (this.GRID_SIZE - indoorSize) * this.TILE_SIZE / 2;
                const offsetY = (this.GRID_SIZE - indoorSize) * this.TILE_SIZE / 2;
                
                for (let y = 0; y < indoorSize; y++) {
                    for (let x = 0; x < indoorSize; x++) {
                        const tile = this.currentHouse.indoorMap[y][x];
                        
                        this.ctx.fillStyle = '#8b4513';
                        this.ctx.fillRect(
                            x * this.TILE_SIZE + offsetX, 
                            y * this.TILE_SIZE + offsetY, 
                            this.TILE_SIZE, 
                            this.TILE_SIZE
                        );
                        
                        this.ctx.strokeStyle = '#a0522d';
                        this.ctx.strokeRect(
                            x * this.TILE_SIZE + offsetX, 
                            y * this.TILE_SIZE + offsetY, 
                            this.TILE_SIZE, 
                            this.TILE_SIZE
                        );
                        
                        if (tile) {
                            this.ctx.font = `${this.TILE_SIZE * 0.6}px Arial`;
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            
                            if (tile.type === 'üß±') this.ctx.fillStyle = '#795548';
                            else if (tile.type === 'üõãÔ∏è') this.ctx.fillStyle = '#ff9800';
                            else if (tile.type === 'üì∫') this.ctx.fillStyle = '#2196F3';
                            else if (tile.type === 'ü™ë') this.ctx.fillStyle = '#8d6e63';
                            else if (tile.type === 'üõèÔ∏è') this.ctx.fillStyle = '#e91e63';
                            else if (tile.type === 'üì¶') this.ctx.fillStyle = '#ffd700';
                            else if (tile.type === 'üö™') this.ctx.fillStyle = '#4CAF50';
                            else if (tile.food) {
                                if (tile.type === 'üçé') this.ctx.fillStyle = '#f44336';
                                else if (tile.type === 'üçó') this.ctx.fillStyle = '#ff9800';
                                else if (tile.type === 'ü•§') this.ctx.fillStyle = '#2196F3';
                                else this.ctx.fillStyle = '#ffd700';
                            } else {
                                this.ctx.fillStyle = '#ffffff';
                            }
                            
                            this.ctx.fillText(
                                tile.type,
                                x * this.TILE_SIZE + offsetX + this.TILE_SIZE / 2,
                                y * this.TILE_SIZE + offsetY + this.TILE_SIZE / 2
                            );
                        }
                    }
                }
                
                this.players.forEach((player, index) => {
                    if (!player.alive || player.inHouse !== this.currentHouse) return;
                    
                    const x = player.indoorPos.x;
                    const y = player.indoorPos.y;
                    
                    this.drawPlayer(player, index, x, y, offsetX, offsetY);
                });
            }
            
            drawIndoorCombat() {
                const houseCanvas = document.getElementById('house-canvas');
                const ctx = houseCanvas.getContext('2d');
                const indoorSize = 8;
                const tileSize = Math.floor(houseCanvas.width / indoorSize);
                
                ctx.clearRect(0, 0, houseCanvas.width, houseCanvas.height);
                
                for (let y = 0; y < indoorSize; y++) {
                    for (let x = 0; x < indoorSize; x++) {
                        const tile = this.currentHouse.indoorMap[y][x];
                        
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                        
                        ctx.strokeStyle = '#a0522d';
                        ctx.strokeRect(x * tileSize, y * tileSize, tileSize, tileSize);
                        
                        if (tile) {
                            ctx.font = `${tileSize * 0.6}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            
                            if (tile.type === 'üß±') ctx.fillStyle = '#795548';
                            else if (tile.type === 'üõãÔ∏è') ctx.fillStyle = '#ff9800';
                            else if (tile.type === 'üì∫') ctx.fillStyle = '#2196F3';
                            else if (tile.type === 'ü™ë') ctx.fillStyle = '#8d6e63';
                            else if (tile.type === 'üõèÔ∏è') ctx.fillStyle = '#e91e63';
                            else if (tile.type === 'üì¶') ctx.fillStyle = '#ffd700';
                            else if (tile.type === 'üö™') ctx.fillStyle = '#4CAF50';
                            else if (tile.food) {
                                if (tile.type === 'üçé') ctx.fillStyle = '#f44336';
                                else if (tile.type === 'üçó') ctx.fillStyle = '#ff9800';
                                else if (tile.type === 'ü•§') ctx.fillStyle = '#2196F3';
                                else ctx.fillStyle = '#ffd700';
                            } else {
                                ctx.fillStyle = '#ffffff';
                            }
                            
                            ctx.fillText(
                                tile.type,
                                x * tileSize + tileSize / 2,
                                y * tileSize + tileSize / 2
                            );
                        }
                    }
                }
                
                this.currentHouse.playersInside.forEach(playerIndex => {
                    const player = this.players[playerIndex];
                    if (!player.alive || !player.indoorPos) return;
                    
                    const x = player.indoorPos.x;
                    const y = player.indoorPos.y;
                    
                    ctx.fillStyle = this.getPlayerColor(playerIndex);
                    ctx.beginPath();
                    ctx.arc(
                        x * tileSize + tileSize / 2,
                        y * tileSize + tileSize / 2,
                        tileSize / 2 - 4,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                    
                    ctx.font = `${tileSize * 0.6}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#fff';
                    ctx.fillText(
                        player.emoji,
                        x * tileSize + tileSize / 2,
                        y * tileSize + tileSize / 2
                    );
                });
            }
            
            drawPlayer(player, index, x, y, offsetX = 0, offsetY = 0) {
                const screenX = x * this.TILE_SIZE + offsetX;
                const screenY = y * this.TILE_SIZE + offsetY;
                
                this.ctx.fillStyle = this.getPlayerColor(index);
                this.ctx.beginPath();
                this.ctx.arc(
                    screenX + this.TILE_SIZE / 2,
                    screenY + this.TILE_SIZE / 2,
                    this.TILE_SIZE / 2 - 6,
                    0,
                    Math.PI * 2
                );
                this.ctx.fill();
                
                this.ctx.font = `${this.TILE_SIZE * 0.6}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillStyle = '#fff';
                
                if (index === this.currentPlayer) {
                    this.ctx.save();
                    
                    const pulseScale = 1 + 0.1 * Math.sin(Date.now() / 200);
                    this.ctx.translate(
                        screenX + this.TILE_SIZE / 2,
                        screenY + this.TILE_SIZE / 2
                    );
                    this.ctx.scale(pulseScale, pulseScale);
                    this.ctx.translate(
                        -(screenX + this.TILE_SIZE / 2),
                        -(screenY + this.TILE_SIZE / 2)
                    );
                    
                    this.ctx.shadowColor = this.getPlayerColor(index);
                    this.ctx.shadowBlur = 15;
                }
                
                this.ctx.fillText(
                    player.emoji,
                    screenX + this.TILE_SIZE / 2,
                    screenY + this.TILE_SIZE / 2
                );
                
                if (index === this.currentPlayer) {
                    this.ctx.restore();
                }
                
                const barWidth = this.TILE_SIZE - 10;
                const barHeight = 6;
                const barX = screenX + 5;
                const barY = screenY - 10;
                
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(barX, barY, barWidth, barHeight);
                
                const healthPercent = player.hp / player.maxHp;
                const healthWidth = healthPercent * barWidth;
                
                if (healthPercent > 0.5) {
                    this.ctx.fillStyle = '#4CAF50';
                } else if (healthPercent > 0.25) {
                    this.ctx.fillStyle = '#ff9800';
                } else {
                    this.ctx.fillStyle = '#f44336';
                }
                
                this.ctx.fillRect(barX, barY, healthWidth, barHeight);
                
                this.ctx.fillStyle = '#fff';
                this.ctx.font = `${this.TILE_SIZE * 0.2}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.fillText(
                    player.hp,
                    barX + barWidth / 2,
                    barY + barHeight / 2 + 4
                );
            }
            
            getPlayerColor(index) {
                const colors = ['#ff5252', '#2196F3', '#ffeb3b', '#e91e63'];
                return colors[index] || '#999';
            }
            
            gameLoop() {
                if (this.gameActive) {
                    if (this.isIndoor) {
                        this.drawIndoor();
                    } else {
                        this.draw();
                    }
                }
                
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        const game = new BattleRoyaleGame();
        window.game = game;
        
        document.addEventListener('contextmenu', (e) => {
            if (window.innerWidth <= 1200) {
                e.preventDefault();
            }
        });
    </script>
</body>
</html>
